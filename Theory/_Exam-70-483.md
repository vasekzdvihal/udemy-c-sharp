# C# Basics

- Simple - fewer operators, no pointers, etc.
- Modern - Garbage collection, improved security
- Object oriented
    - Encapsulation, inheritance, polymorphism
    - No global functions, variables or constants
    - Everything is encapsulated inside a class
- Type safe
    - Cannot use uninitialised variables
    - Unsafe casts are not allowed
- Versionable - C# supports the versioning functionality provided by Common Language Specifications (CLS)
- Compatible
    - Allow you to access different APIs
    - Compiler insures CLS Compliance
- Flexible
    - Classes and/or methods can be declared as unsafe
    - Establishing use of pointers and other items that are required to use other APIs

## Object Oriented Programming

- Program functionality is grouped into and carried out by objects
- The objects are defined by classes that are used to create the objects
  Advantages
- Code is divided into stand-alone groups
- Code can be easily re-used
- Complexity is reduced
- De-coupling can be achieved
- Extensibility

Three main characteristics of OOP

I. ENCAPSULATION

- Grouping of data and functions into a single component
- Allows selective 'hiding' of data and functionalities
- Provides security and ease of use for objects
- Example: Making a call using smartphone

II. INHERITANCE

- Enables one class to reuse code from another class
- A single object can passes the the functionality of multiple classes
- Avoids code duplications
- Provides the ability to extend and modify behaviour in an easily maintained environment

III. POLYMORPHISM

- The result of inheritance and encapsulation
- The ability to provide different functionalities for the same method name
- Based on the context of how the method is called
- An inheritance hierarchy of classes and objects can provide multiple functions bearing the same name, but different
  functionalities

## Classes

What does a class do?

- A class is a template that is used to create objects
- Provides necessary details for building software objects
- A class is the software version
- A class is similar to blueprint that is used to construct buildings
- A blueprint, can be used to construct multiple buildings
- A class can be used to create multiple objects

## Objects

A objects is a variable that contains two things:

- The properties that were defined in the class
- The abilities defined as methods in the class
- Multiple objects can be create based on a single class
- Each object has its own 'state' or unique collection of data values
- Making a change to a class will affect every object created from that class

## C# Types

- C# is a strongly-typed language
  - Every variable and constant has a specific type
  - Expressions that evaluate to value have a type
- What exactly is a type?
  - A type specifies up to four main characteristics of data that can be storage
    - The storage space that a variable of the type requires
    - The maximum and minimum values that it can represent
    - The members (methods, fields, events, and so on...) that it contains
    - The base type it inherits from
- What does 'type-safe' means?
  - The compiler makes sure that all operations performed are valid for the type of data being manipulated
- C# provides a standard set of built-in types
  - Numeric
  - String
  - Object
- Types are divided into two categories
  - VALUE TYPES
  - REFERENCE TYPES

### Value and reference type

- The .NET Framework stores item in memory in one of two locations
  - Stack
  - Heap
- Value types are stored on the Stack
- Reference types are stored on the Heap

- Let's look at value types stored on the Stack...
  - Each variable is stored on the stack in the order it was created
  - Each variable stores its own data
  - The amount of memory required to store a value type is a set amount
  - When the variable is no longer needed, it is deleted from the stack
- Now, let's look at reference values...
  - The variable is stored on the stack
  - The data is stored on the heap

### Collection and Arrays

There are two ways to create and manage groups of related objects in C#

- Creating an array of objects
- Creating a collection of objects

- Arrays store multiple variables of the same type in an array data structure
- Collections provide a flexible way to work with groups of objects
  - Unlike arrays, the group of objects can grow and shrink dynamically
  - There are a number of different kinds of collections


    using System;
    using System.Collections.Generic;
    
    namespace Collection_and_Arrays
    {
        class Program
        {
            static void Main(string[] args)
            {
                // Create a collection that is a list of strings
                var dogs = new List<string>();
    
                dogs.Add("Bulldog");
                dogs.Add("Collie");
                dogs.Add("Retriever");
    
                // foreach to move through the list
                foreach(var dog in dogs)
                {
                    Console.WriteLine(dog + " ");
                }
    
                Console.WriteLine(dogs[1]);
    
                // Create a array of integers
                int[] a1 = new int[] { 1, 3, 5, 7, 9, 11 };
    
                foreach(int i in a1)
                {
                    Console.WriteLine(i + " ");
                }
            }
        }
    }

## Exception Handling

- In C#, unexpected or exceptional situations are called 'exceptions'
  - When an exception occurs, it 'bubbles up' through the call stack looking for code that catches and handles the
    exception
- C# provides the Try, Catch, Finally block to handle exceptions
  - It should be used around statements that might cause an exception
- Exceptions are represented by classes
  - These classes are derived from Exception
  - This class identifies the type of exception and contains properties that have details about exception
    Syntax

1. TRY (All code in the TRY block is executed)
2. CATCH (if an exception occurs, the code in the CATCH block is executed)
3. FINALLY [optional] (This code is always executed)
   Exception can be raised in code using "throw"


    using System;
    
    namespace Exception_Example
    {
        class Program
        {
            static void Main(string[] args)
            {
                int a = 4;
                int b = 0;
    
                try
                {
                    Console.WriteLine("a divided by b is: " + a / b);
                }
                catch(Exception e)
                {
                    Console.WriteLine("The following error has occured: " + e.Message);
                }
                finally
                {
                    Console.WriteLine("Finally has been called...");
                }
    
                Console.WriteLine("... the program continues...");
            }
        }
    }

## String Builder

- In C# a string is an object of type String whose value is text
  - Internally, the text is stored as a sequential readonly collection of Char objects
- The string keyword is an alias for String
- String objects are immutable
  - They cannot be changed after they have been created
  - All methods and operation that appear to modify a string actually create a new string
- String operations in .NET are highly optimised
  - Under most conditions their use will not impact performance
  - Looping functions that execute hundreds or thousands of times performing string operations can affect performance
- The StringBuilder class creates a string buffer that provides better performance in these situations 


    using System;
    using System.Text;
    
    namespace String_Builder
    {
        class Program
        {
            static void Main(string[] args)
            {
                string s1 = "This is an example of ";
                s1 = s1 + "string concatenation";
                Console.WriteLine(s1);
    
                StringBuilder sb2 = new StringBuilder("This is an example of ");
                sb2.Append("string concatenation");
                Console.WriteLine(sb2);
    
                sb2.AppendLine();
                sb2.Append(" using StringBuilder...");
                Console.WriteLine(sb2);
    
                sb2.Replace("StringBuilder", "the StringBuilder class");
                Console.WriteLine(sb2); 
            }
        }
    }

## StringWriter and StringReader

- These classes provide the ability to manipulate string data inside a StringBuilder object
  - StringWriter writes to the StringBuilder object
  - StringReader read string data from the StringBuilder object
  - Use them when you are dealing with lot of string manipulation


    using System;
    using System.IO;
    using System.Text;
    
    namespace StringWriter_And_StringReader
    {
        class Program
        {
            static void Main(string[] args)
            {
                StringReadWrite srw = new StringReadWrite();
            }
        }
    
        #region "Write data using StringWriter"
        public class StringReadWrite
        {
            StringBuilder sb = new StringBuilder();
    
            public StringReadWrite()
            {
                WriteData();
                ReadData();
            }
    
            public void WriteData()
            {
                StringWriter sw = new StringWriter(sb);
    
                Console.WriteLine("Please enter you first and last name...");
                string name = Console.ReadLine();
    
                sw.WriteLine("Name: " + name);
                sw.Flush();
                sw.Close();
            }
            #endregion
            #region "Read data from the StringBuilder object"
            public void ReadData()
            {
                StringReader sr = new StringReader(sb.ToString());
    
                Console.WriteLine("Reading the information...");
    
                while(sr.Peek() > -1)
                {
                    Console.WriteLine(sr.ReadLine());
                }
    
                Console.WriteLine();
                Console.WriteLine("Thank you!");
    
                sr.Close();
            }
            #endregion
        }
    }

# Working with C# types

## Properties and fields

- Properties and fields provides objects the ability to store data
  - Consider a Person object
  - Gender
  - Weight
  - Age
- The are ofter called '_properties_' 
- How should we provide the ability to set and change this data? 
  - Uncontrolled access to data can create serious issues
  - Invalid values can cause errors
  - Invalid values can create security concerns
- Encapsulation solves the problem
  - And explains the difference between properties nad fields
  - This principle states that data stored inside an object
  - Not directly publicly accessible from outside the object
- Fields provide the ability to store data privately
- Properties provide the ability to access and change data privately
  - A field is only available from within the object
- Properties provide the ability to read and write data to the private fields
  - Specifically, they provide encapsulation for the fields
  - Data being written to or read from a field can be verified, modified, ect.
- Properties look and feel like public data members
  - The are actually special methods called accessors
  - Here's the short version...
    - A fields is a private variable that can only be accessed by code withing the object
    - A property is used to provide public access to the private field
  

    class Program
    {
      static void Main(string[] args)
      {
        Person p = new Person();
        p.Age = 91;
        p.Weight = 75;
      
        Console.WriteLine("Age: " + p.Age);
      }
    }
  
    public class Person
    {
      public string Firstname { get; set; }
      public int Weight { get; set; }
  
      private int age;

      public int Age
      {
        get
        {
          return age;
        }
        set
        {
          if ((value > 0) && (value < 65))
          {
              age = value;
          }
          else
          {
              throw new Exception("Age cannot be over 65...");
          }
        }
      }
    }

## Methods

- A method is a named code block that carries out a series of statements
  - A program causes the statements to be executed by calling the method and specifying any required method arguments
  - Similar to subroutines in other languages
  - In C#, every executed instruction is performed in the context of method
- Method have a few characteristics you should understand
  - Access modifier
    - Controls the availability of the method to other code
    - See 'ACCESS MODIFIERS'
  - Return type
    - Method can return a value to the calling code
    - Sometimes called a function when it's return a value
    - If the return type is not '_void_' the method will return a value
    - A '_return_' statement inside the method will stop execution and return a value to the caller if the value matches the return type
    - If the value matches the return type
  - Parameters
    - Specifies the name and data type of values that must be provided when the method is called
    - The values passed to the methods parameters are called arguments
    - The arguments must be compatible with the parameter data type
  - Signature
    - Refers to the structure of the method
    - For overloading, the signature includes the method name and the parameter types
    - For delegates, the signature includes the return type and the parameter types
  - Access modifiers
    - All type and members have an accessibility level
      - Controls wheaten they can be used from other code within and assembly or other assembly
    - Five accessibility levels
      - Public
        - The type or member can be accessed by any other code in the same assembly or another assembly that references it
      - Private
        - The type or member can be accessed only by code in the same class or struct
      - Protected
        - The type or member can be accessed only by code in the same class or struct, or in a class that is derived from that class
      - Internal
        - The type or member can be accessed by any code in the same assembly, but not from another assembly
      - Protected internal
        - The type or member can be accessed by any code in the assembly in which it is declared...
        - Or from within a derived class in another assembly

### Named and optional arguments

- NOTE: The words '_parameters_' and '_arguments_' are often used interchangeably
- A method's parameters are usually utilized positionally


    public int NewInfo(string fname, int age) 
    {
      // ...
    }

    NewInfo("John", 25);

- Named argument can be used instead if positional


    NewInfo(age: 25, fname: "John");

- By default, all parameters listed are required when calling the method
- Optional parameters can be defined
  - Each optional parameter has a default value as part of it's definition
  - If no argument is send for that parameter, the default value is used
- Optional parameters are defined at the end of the parameter list, after any required parameters


    public int NewInfo(string fname, int age, string lname = "Smith") 
    {
      // ...
    }

    NewInfo("John", 25);


### Understanding constructors

- Every class or struct has a constructor
- What is a constructor? 
  - A method that executes automatically every time an object is instantiated from the class
  - A method with same name as the class
  - If a constructor is not provided by the programmer, C# creates a default contructor
- What does a constructor do?
  - Enables actions to be taken as an object is created based on the class
  - Set default values
  - Limit instantiation
  - Take a specific action
  - Ect.
- There are three main types of constructors
  - INSTANCE
    - Used to create and initialize any instance member variables when you use the new expression to create an object of a class
  - PRIVATE
    - Prevents other classes from creating instances of this class.
    - Only nested classes can create an instance of this class
  - STATIC
    - Used to initialize any static data
    - A static constructor is called only once before the first instance of the class is created or any static members are referenced
  - CONSTRUCTORS CAN BE OVERLOADED


    class Program
    {
      static void Main(string[] args)
      {
        DefContructor dc = new DefContructor();
        dc.DoThis();

        AddConstrutor ac = new AddConstructor();
      }
    }
  
    public class DefContructor
    {
      public void DoThis()
      {
        Console.WriteLine("Do this...");
      }
    }

    public class AddConstructor
    {
      public AddConstructor()
      {
        Console.WriteLine("Add constructor...");
        DoThat();
      }

      public void DoThat() 
      {
        Console.WriteLine("Do that...");
      }
    }
    
    // Output
    // Do this...
    // Add constructor...
    // Do that...


### Understanding Static

-The static modifier changing the behavior of C# types and members
- What's the difference?
  - A static class class or member cannot be accessed through an instance
- Classes and methods can be marked as static
  - In static class, all methods must be marked as static
- A non-static class is used to create multiple objects based on the non-static type
  - Objects are created using the 'new' keyword
- You cannot use the 'new' keyword with a static class
  - Only one instance of the object ever exists.


      class Program
      {
        static void Main(string[] args)
        {
          double r = Math.Round(35.5);
          Console.WriteLine(r);
      
          Car.Accelerate();
          
          Car c = new Car();
          c.Accelerate();
        }
      }

      public class Car
      {
          public static void Accelerate()
          {
            Console.WriteLine("Accelerate...");
          }
      }

### Understating Structs

- Structs is very similar to a class
  - It looks and acts like a class
  - But is a value type, not a reference type
- Structs share many functionalities of classes
  - Fields, properties, methods, events, indexers, operators, constructors, finalizers, and nested types
  - Can implement interfaces
  - Instantiated using the 'new' keyword
- How structs are different from classes
  - Cannot declare a default constructor (a constructor without parameters)
  - Cannot inherit from other structs or classes
  - Can be instanced without the 'new' keyword but there is no constructor call and all fields must be initialized before use


    class Program {
      static void Main(string[] args) {
        Mark m = new Mark(6, 7);
        m.DoThis();
    
        John j;
        j.age = 25;
        j.name = "John";
        j.DoThat();
      }
    }
    
    public struct Mark {
      public int x;
      public int y;
    
      public Mark(int p1, int p2) {
        x = p1;
        y = p2;
      }
    
      public void DoThis() {
        Console.WriteLine("Do this...");
      }
    }
    
    public struct John {
      public int age;
      public string name;
    
      public void DoThat() {
        Console.WriteLine("Do that...");
      }
    }

### Generic types

- What are generic? 
  - Collections that are type-safe at compile time
  - A faster, safer, more efficient way to deal with collections
  - Introduced in C# 2.0
  - Make it possible to design classes and methods that defer the specification of one or more types until the class or method is declared and instantiated by client code
  - Generics provide the solution to a limitation in earlier versions of the common language runtime and the C# language
  - Prior to C# version 2.0, collections such as ArrayList and Hashtable were not generic
  - Generalization was accomplished by casting types to and from the universal base type Object
  - Why do wee need generics?
    - Items (value or reference types) that were added to an ArrayList were implicitly cast to type Object
    - Value types require boxing to be added and unboxing when retrieved
    - Boxing can seriously affect performance


    class Program 
    {
        static void Main(string[] args) 
        {
            ArrayList list1 = new ArrayList();
            list1.Add(1);
            list1.Add(2);
            list1.Add(3);
        
            Console.WriteLine("Non-generic List results...");
            foreach (int x in list1) 
            {
              Console.WriteLine(x);
            }
        
            List<int> list2 = new List<int>();
            list2.Add(1); 
            list2.Add(2);
            list2.Add(3);
        
            Console.WriteLine("Generic List results...");
            foreach (int x in list2) 
            {
              Console.WriteLine(x);
            }
        }
    }
      

### Casting and converting

- C# variables are statically types
  - Data types are assigned to variables and the data type are checked of compile time
- This type checking helps prevents bugs
- There are many instances where a variable of a specific type needs to store data  of a different type
- Casting and converting are the processes provided by C# to handle these situations
- There are two main kinds of type conversions in C#
  - IMPLICIT
    - These conversions happen automatically when there is no possibility of data loss
    - A variable of type long (8-byte integer) can store a value than a variable of type int (4-byte integer)
  - EXPLICIT
    - If the conversion cannot be made without the rist of losing information (larger to smaller), the conversion must be explicit
    - Called a cast
    - Informs the compiler that you understand that data loss may occur
  - C# also provides the convert class for converting between types
    - Convert provides similar functionality but gets a little more complex under the hood
    - Convert is great when working with strings
    - Simplest answer: Try cast, if it fails, try convert


    class Program
    {
      static void Main(string[] args)
      {
        int x = 7;
        double y = 12.6;
        x = (int)y;
        Console.WriteLine("Double casted to int: " + x); // 12
    
        int xx = 7;
        double yy = 12.6;
        xx = Convert.ToInt32(yy);
        Console.WriteLine("Double converted to int: " + xx); // 13
    
        string s = "123";
        int r;
        r = Convert.ToInt32(s);
        Console.WriteLine("String converted to int: " + r); // 123  
      }
    }


### Boxing and unboxing

- C# is based on a unified type system
  - Everything can be an object
  - But there are two types of types
    - Value types
      - Primitive types
      - Structs
    - Reference types
      - Classes
      - Arrays
      - Delegates
      - Strings
  - Value and reference type are stored and managed differently
    - Value types are stored on the stack
    - Reference types are stored on the heap
  - Boxing provides a common way to handle both types
- Example: A collection of objects has been created 
  - And we want to add an integer variable into the collection
  - Boxing allows this
  - The integer variable is wrapped in a System.Object
  - Now it is stored on the heap as a reference type and not on the stack as a value type
    - Boxing is an implicit conversion
    - Unboxing is an explicit conversion
    - Excessive boxing can get expensive


    class Program 
    {
        static void Main(string[] args) 
        {
            object o;
            int x = 25;
    
            o = x; // boxing
            Console.WriteLine("o=" + o);
            Console.WriteLine("x=" + x);
    
    
            o = 123;
            x = (int)o; // unboxing
            Console.WriteLine("o=" + o);
            Console.WriteLine("x=" + x);
        }
    }


### Indexers

- An indexers provides the ability to access a type using on index similar to an array


    class Program 
    {
        static void Main(string[] args) 
        {
            Person p = new Person();
            p[0] = "John";
            p[1] = "Doe";
            p[2] = "Smith";
        
            Console.WriteLine(p[0]);
            Console.WriteLine(p[1]);
            Console.WriteLine(p[2]);
        }
    }

    public class Person 
    {
        private string[] names = new string[3];
    
        public string this[int index] 
        {
            get 
            {
                return names[index];
            }
            set 
            {
                names[index] = value;
            }
        }
    }


## Implementing Class Hierarchies

### The magic of Inheritance

- Inheritance is one of the three pillars of object-oriented programming
- Inheritance enables you to create new classes that reuse, extend and modify the behavior that is defined in other classes
- Writing some code in two different classes is going to become problem
  - Changes in properties or methods must be made in two classes
  - What if more classes are added with duplicate items
- What if we could 'share' the some functionality between the two classes
- Inheritance is the answer
- Inheritance provides the ability to write code once and use it in many different locations
  - It also adds a few design options and considerations

### Using Inheritance

- Inheritance provides a number of efficiencies
  - It also provides a few design considerations
- Inheritance is usually implemented in a 'general down to specific' modul
- There are a few terms you should be comfortable with
  - Base class
    - The class that is being inherited from
  - Derived class
    - The class that is inheriting from the base class
  - Base class member
    - A member of the base class
  - Derived class member
    - A member of the derived class
  - Base class reference
    - A reference to a base class
  - Derived class reference
    - A reference to a derived class


    class Program 
    {
        static void Main(string[] args) 
        {
            Patient p = new Patient();
            p.Examine("Jamison");
    
            Child c = new Child();
            c.Examine("Bobby");
            c.Inoculate();
    
            UnderFive uf = new UnderFive();
            uf.Examine("Sally");
            uf.UnderFiveMethod();
        }
    }
    
    public class Patient 
    {
        public string Name { get; set; }
        public int Age { get; set; }
        public int Weight { get; set; }
        public long PatientNumber { get; set; }
    
        public void Examine(string name) 
        {
            Console.WriteLine("Examining patient: " + name);
        }
    }
    
    public class Child : Patient 
    {
        public void Inoculate() 
        {
            Console.WriteLine("Inoculating child");
        }
    }
    
    public class UnderFive : Child 
    {
        public void UnderFiveMethod() 
        {
            Console.WriteLine("UnderFiveMethod");
        }
    }


### Understanding Overloading

- A method is a code block that contains a series of statements
- Every method has a 'signature'
  - Just like your signature, it is unique to the method 
  - Can be used to identify the method
- Multiple methods can be created using the same name 
  - As long as the signatures are unique
- We can 'overload' methods based on their unique signatures
  - For the purpose of overloading, a method's signature is it's name and the parameters it accepts


    class Program 
    {
        static void Main(string[] args) 
        {
            Patient p = new Patient();
            p.CheckBilling();
            p.CheckBilling(123, 1);
            p.CheckBilling("Jamison", 1);
    
            Child c = new Child();  
            c.CheckBilling("c", "a"); 
        }
    }
    
    public class Patient 
    {
        public void CheckBilling() 
        {
          Console.WriteLine("CheckBilling");
        }
      
        public void CheckBilling(int id, int type) 
        {
            Console.WriteLine("CheckBilling with two integers");
        }
        
        public void CheckBilling(string name, int type) 
        {
            Console.WriteLine("CheckBilling with string and integer");
        }
    }
    
    public class Child : Patient 
    {
        public void CheckBilling(string name, string type) 
        {
            Console.WriteLine("CheckBilling with string and string");
        }
    }


### Overriding methods

- Inheritance allows the Adult class to utilize the examine method in the Patient class
  - What if we add an Examine method to the Adult class that provides different functionality from the Patient class
  - How do we use the Examine method in the Adult class
- An override method provides a new implementation of a member that is inherited from a base class
- Overriding a method requires the use of two keywords
  - The base method that is being replacer, or overriden must include the keyword 'virtual'
  - The overriding method must include the keyword 'override'


    class Program 
    {
        static void Main(string[] args) 
        {
            Patient p = new Patient();
            p.Examine();
        
            Adult a = new Adult();
            a.Examine();
        }
    
        public class Patient 
        {
            public virtual void Examine() 
            {
                Console.WriteLine("Patient Examine");
            }
        }
    
        public class Adult : Patient 
        {
            public override void Examine() 
            {
                Console.WriteLine("Adult Examine");
            }
        }
    }


### Extension methods 

- Sometimes you'd like to add a particular functionality to a class that already exists
- Extensions methods provide a way to do this
  - Without creating a new derived type
  - Without recompiling the original type
  - Without modifying the original type
- An extension method is actually static method in a static class
  - The 'this' keyword is applied to the first method parameter
  - The type of the first parameter is the type that will he extended


    class Program 
    {
        static void Main(string[] args) 
        {
            string s = "Jamison";
            Console.WriteLine(s.GetFirstLetter());
        }
    }
    
    public static class StringExtensions 
    {
        public static string GetFirstLetter(this string s) 
        {
            return s.Substring(0, 1);
        }
    }


### Understanding Interfaces

- What is interface? 
  - A contract that defines a set of methods and properties that a class must implement
- What interface accomplish?
  - Consistency
  - Polymorphism
- An interface in C# provides similar functionality for our classes
  - It defines what functionalities a class must implement
  - It does not provide the specific functionality
- One important note about interfaces...
  - Classes can implement multiple interfaces
  - Classes can only inherit from one base class

### Creating an interface

- An interface contains definitions for a group of related functionalities that a class or struct must provide
  - SW Version of a contract
- An interface tells a class what it must do
  - It does not tell the class hwo to do it
- What can on interface define
  - Methods
  - Properties
  - Events
  - Indexers
- Interface members are automatically public
- Interface members can't include any access modifiers
- A class implement an interface
  - It agreed to the terms of the contract
  - It must provide an implementation for all of the interface members


    class Program 
    {
        static void Main(string[] args) 
        {
            Machine1 m1 = new Machine1();
            Machine2 m2 = new Machine2();
            Machine3 m3 = new Machine3(); 
    
            m1.Start();
            m1.Stop();
            m2.Start(); 
            m2.Stop();  
            m3.Start(); 
            m3.Stop();  
        }
    }
        
    public class Machine1 : IControls 
    {
        public void Start() 
        {
            Console.WriteLine("Machine1 Start");
        }
        
        public void Stop() 
        {
            Console.WriteLine("Machine1 Stop");
        }
    }
    
    public class Machine2 : IControls 
    {
        public void Start() 
        {
            Console.WriteLine("Machine2 Start");
        }
        
        public void Stop() 
        {
            Console.WriteLine("Machine2 Stop");
        }
    }
    
    public class Machine3 : IControls 
    {
        public void Start() 
        {
            Console.WriteLine("Machine3 Start");
        }
        
        public void Stop() 
        {
            Console.WriteLine("Machine3 Stop");
        }
    }
    
    public interface IControls 
    {
        void Start();
        void Stop();
    }


### Explicit interface implementation

- C# dues not allow multiple inheritance
- C# dies allow a class to implement multiple interfaces
- Explicit interface implementation can be utilized to resolve the problem


    class Program 
    {
      static void Main(string[] args) 
      {
        Mark m = new Mark();
        m.DoThis();
    
        ((ISecond)m).DoThis();
    
        ISecond s = new Mark();
        s.DoThis();
      }
    }
    
    interface IFirst 
    {
      void DoThis();
    }
    
    interface ISecond 
    {
      void DoThis();
    }
    
    class Mark : IFirst, ISecond 
    {
      void IFirst.DoThis() 
      {
          Console.WriteLine("IFirst.DoThis");
      }
    
      void ISecond.DoThis() 
      {
          Console.WriteLine("ISecond.DoThis");
      }
    }


### IEnumerable

- Computers programs deal with various collections of data
- C# provides a number of collection types
  - Array
  - List
  - Dictionary
  - Stack
  - Queue
- The internals of these collections may be very different
- The need to traverse the contents of these collections is universal
  - Locate items, populate, controls, ect...
- C# provides the foreach construct to make collection iteration simple across various collection types
- The .NET Framework provides two interfaces to provide a standardized method of accessing collection data
  - IEnumerable
  - IEnumerator
- Note that since we are using interfaces, the code for providing enumeration resides in a separate class
  - Multiple enumerator objects can run simultaneously on the same collection
- The IEnumerable interface defines one method for iterating through a collection
  - public IEnumerator GetEnumerator()
  - Note that GetEnumerator returns an IEnumerator object
- The IEnumerator interface defines three methods that provide the functionality to iterate through a collection
  - bool MoveNext()
  - void Reset()
  - object Current { get; }
- Implementing IEnumerable requires you to provide an implementation for the GetEnumerator method
- There are three ways to implement IEnumerable
  - Implement IEnumerable and IEnumerator in the same class
  - Implement IEnumerable and IEnumerator in separate classes
  - Implement IEnumerable and IEnumerator in separate classes, but use an inner class to implement IEnumerator

### Implementing IEnumerable

- The IEnumerable interface defines a single method that returns an IEnumerator object
  - public IEnumerator GetEnumerator()
- To implement IEnumerable, we need to provide functionality for the GetEnumerator method
  - We need to write an iterator that moves through the collection and returns the current item
- The 'yield return' statement provides the functionality to return the current item and move to the next item
  - 'yield return' is a special type of return statement
  - It causes the compiler to create a hidden enumerator class behind the scenes


    class Program 
    {
        static void Main(string[] args) 
        {
            List<string> cars = new List<string>();
            cars.Add("BMW");
            cars.Add("Audi");
            cars.Add("Mercedes");
            cars.Add("Volvo");
    
            foreach (string car in cars) 
            {
                Console.WriteLine(car);
            }
    
            Console.WriteLine("\n" + "Now our own collection..." + "\n");
    
           Car c = new car();
           c[0] = "BMW";
           c[1] = "Audi";  
           c[2] = "Mercedes";
    
          foreach (string car in c) 
          {
            Console.WriteLine(car);
          }
        }
    }
        
    public class Car : IEnumerable 
    {
        private string[] cars = new string[3];
        
        public string this[int index] 
        {
            get { return cars[index]; }
            set { cars[index] = value; }
        }
        
        public IEnumerator GetEnumerator() 
        {
            foreach (string car in cars) 
            {
                yield return car;
            }
        }
    }

## Understanding Delegates

### What is a delegate?

- Delegate is an object that knows how to call a method
- A delegate is a type (like a class)
  - It defines the method signature that can be called
  - A delegate considers the method signature to include the return type and the parameters types
- If we create a delegate type using this code


    delegate int d(int, int);

- We create a variable 'd' that is a type of delegate
- 'd' can now be used to call any method that returns an int and has two int parameters


    class Program
    {
        static void Main(string[] args)
        {
            d myDelegate = new d(Add);
            int result = myDelegate(3, 4);
            Console.WriteLine(result);
        }
    
        static int Add(int x, int y)
        {
            return x + y;
        }
    }


### Multicast Delegates

- All C# delegates have multicast capability
  - A single delegate instance can reference more than one target method
  - A target method can be added to a delegate instance using += operator and removed using -= operator
  - Target methods are called in the order they were added to the delegate instance


    class Program
    {
        static void Main(string[] args)
        {
            d myDelegate = new d(Add);
            myDelegate += Subtract;
            int result = myDelegate(3, 4);
            Console.WriteLine(result);
        }
    
        static int Add(int x, int y)
        {
            return x + y;
        }
    
        static int Subtract(int x, int y)
        {
            return x - y;
        }
    }


## Understanding Events

### What is an event?
- Events enable a class or object a class or object to notify other classes or objects when something of interest occurs
  - The class or object that sends (or raises) the event is called the publisher
  - The classes or objects that receive (or handle) the event are called subscribers
- Events have the following characteristics
  - The publisher determines when an event is raised
  - The subscriber determines what action to take when an event is raised
  - An event can have multiple subscribers
  - An event can be raised by a publisher without any subscribers
  - An event can be raised by a publisher with multiple subscribers
  - Events are typically used to signal user interface actions
  - Events are based on the EventHandler delegate and the EventArgs class


    class Program
    {
        static void Main(string[] args)
        {
            Publisher p = new Publisher();
            Subscriber s = new Subscriber();
            p.RaiseCustomEvent += s.OnRaiseCustomEvent;
            p.DoSomething();
        }
    }
    
    public class CustomEventArgs : EventArgs
    {
        public CustomEventArgs(string s)
        {
            msg = s;
        }
    
        private string msg;
    
        public string Message
        {
            get { return msg; }
            set { msg = value; }
        }
    }
    
    public class Publisher
    {
        public event EventHandler<CustomEventArgs> RaiseCustomEvent;
    
        public void DoSomething()
        {
            OnRaiseCustomEvent(new CustomEventArgs("Did something"));
        }
    
        protected virtual void OnRaiseCustomEvent(CustomEventArgs e)
        {
            EventHandler<CustomEventArgs> handler = RaiseCustomEvent;
    
            if (handler != null)
            {
                e.Message += String.Format(" at {0}", DateTime.Now.ToString());
                handler(this, e);
            }
        }
    }
    
    public class Subscriber
    {
        public void OnRaiseCustomEvent(object sender, CustomEventArgs e)
        {
            Console.WriteLine(e.Message);
        }
    }

### Using Event Handlers
- The .NET Framework provides an event that is pre-wired to a delegate
  - The EventHandler event
- Let's look at an example of using the EventHandler event


      
    class Program
    {
        static void Main(string[] args)
        {
            Publisher p = new Publisher();
            p.RaiseCustomEvent += HandleCustomEvent;
            p.DoSomething();
        }
    
        static void HandleCustomEvent(object sender, CustomEventArgs e)
        {
            Console.WriteLine(e.Message);
        }
    }
    
    public class CustomEventArgs : EventArgs
    {
        public CustomEventArgs(string s)
        {
            msg = s;
        }
    
        private string msg;
    
        public string Message
        {
            get { return msg; }
            set { msg = value; }
        }
    }
    
    public class Publisher
    {
        public event EventHandler<CustomEventArgs> RaiseCustomEvent;
    
        public void DoSomething()
        {
            OnRaiseCustomEvent(new CustomEventArgs("Did something"));
        }
    
        protected virtual void OnRaiseCustomEvent(CustomEventArgs e)
        {
            EventHandler<CustomEventArgs> handler = RaiseCustomEvent;
    
            if (handler != null)
            {
                e.Message += String.Format(" at {0}", DateTime.Now.ToString());
                handler(this, e);
            }
        }
    }


### Using EventArgs
- Custom event arguments can be used to make events more meaningful
  - Generics make it easy to create custom event arguments



    class Program
    {
        static void Main(string[] args)
        {
            Publisher p = new Publisher();
            p.RaiseCustomEvent += HandleCustomEvent;
            p.DoSomething();
        }
    
        static void HandleCustomEvent(object sender, CustomEventArgs e)
        {
            Console.WriteLine(e.Message);
        }
    }
    
    public class CustomEventArgs : EventArgs
    {
        public CustomEventArgs(string s)
        {
            msg = s;
        }
    
        private string msg;
    
        public string Message
        {
            get { return msg; }
            set { msg = value; }
        }
    }
    
    public class Publisher
    {
        public event EventHandler<CustomEventArgs> RaiseCustomEvent;
    
        public void DoSomething()
        {
            OnRaiseCustomEvent(new CustomEventArgs("Did something"));
        }
    
        protected virtual void OnRaiseCustomEvent(CustomEventArgs e)
        {
            EventHandler<CustomEventArgs> handler = RaiseCustomEvent;
    
            if (handler != null)
            {
                e.Message += String.Format(" at {0}", DateTime.Now.ToString());
                handler(this, e);
            }
        }
    }


## Garbage Collection

### Garbage Collection basics
- Memory management is a major concert for developers
- Unmanaged programming languages often exhibit some serious behavior
    - Memory leaks
    - Allocated memory that is never reclaimed
- The .NET Framework provides a functionality called Garbage Collection (GC) to avoid the vast majority of memory leaks
  - Unused, unreferenced objects are automatically removed from memory
  - GC Works only on managed memory objects
- There are a few details about GC that you should know
  - GC does not happen immediately once an object is orphaned
  - GC occurs periodically based on available memory, current memory allocation and time since the last collection
  - The delay between collections can range from seconds to days
  - Not all orphaned objects are reclaimed during every collection
  - There are a few instances when helping the GC along is necessary
  - You can force Garbage Collection to occur by calling the GC.Collect() method

### Understanding Dispose 
- Disposal
  - Some resources require explicit code to release resources
  - Open files, database connections, locks, etc. are examples of resources that require explicit disposal
  - Disposal provides the teardown code to release resources
  - The GC reclaims the memory at a later date
  - Disposal is supported via the IDisposable interface
    - Includes a single method
    - void Dispose();
  - There are two ways to implement Disposal
    - Calling the Dispose method directly
    - Using the using statement
  - The compiler converts this t oa try/finally construct that includes Dispose(); in the finally block

### Understanding Dispose
- A finalizer is the opposite of a constructor
  - A constructor is the first opportunity to work with an object
  - A finalizer is the last opportunity to work with an object
  - A finalizer is a method whose name begins with a tilde (~)
- The best way to understand a finalizer is tgo understand how GC works
  - Objects are utilize a pointer on the stack that references to the data stored on the heap
  - When the GC runs, it sees that both objects still have references so no actions is taken
  - The next time the GC runs, both objects no longer have any references
  - Since object A does not have a Finalizer, it is removed from memory
  - Since object B has Finalizer, it is placed into a queue and kept alive
  - The finalizer thread runs and identifies objects in the queue and runs their finalization methods
  - Once finalization has been run, the object becomes orphaned
  - The next time GC runs, the object is removed from memory
  - Finalizers should only be used when necessary
    - Slow the allocation and collection of memory
    - Prolong the life of objects
    - Impossible to predict the order in which finalizers for a set of objects will be called
    - If code in a finalizer blocks, references other finalizers, or throws an exception, the CLR will terminate the process

### Understanding IDisposable
- Applications function by creation object
  - Create and maintain connections to resources 
  - Require memory
- Objects should be 'cleared up' when their use is no longer required
- Objects fall into two categories in a .NET application 
  - MANAGED 
    - Managed objects are automatically cleaned up by the GC function
  - UNMANAGED
    - Non-.NET objects are not cleaned up by GC and must be explicitly closed/removed
    - This process is called Disposal
  - The .NET Framework defines an interface for types requiring explicit disposal action
    - IDisposable
    - Defines a single method
      - void Dispose()



    class BaseClass : IDisposable
    {
        // Flag: Has Dispose already been called?
        bool disposed = false;
        // Instantiate a SafeHandle instance.
        SafeHandle handle = new SafeFileHandle(IntPtr.Zero, true);

        // Public implementation of Dispose pattern callable by consumers.
        public void Dispose()
        { 
            Dispose(true);
            GC.SuppressFinalize(this);           
        }
        
        // Protected implementation of Dispose pattern.
        protected virtual void Dispose(bool disposing)
        {
            if (disposed)
                return; 

            if (disposing) {
                handle.Dispose();
                // Free any other managed objects here.
                //
            }

            // Free any unmanaged objects here.
            //
            disposed = true;
        }
    }

  
- IDisposable should only be implemented when unmanaged resources are being used
- Implementing IDisposable can introduce inefficiencies to the overhead of the finalization process
- Microsoft suggest using a pattern when implementing IDisposable
- The Dispose Pattern is intended to standardize the usage and implementation of finalizers and the IDisposable interface
- Lets take a look at the pattern
  - Create a variable that will be used to keep track of whether Dispose has been called 
    - bool disposed = false;
  - Dispose() is the implementation of the IDisposable interface
    - Make a call to an overloaded Dispose method passing 'true' to the required boolean parameter
  - If disposed is 'true' then Disposal has occured
    - Exit the method and return to the caller
  - Passing 'true' as an argument indicates that the method is being invoked by the user to carry out disposal
    - Release managed and unmanaged objects
    - If the method is invoked from the Finalizer, 'false' will be passed
  - If Disposal was successful, set Disposed to 'true'
  - Execution is returned to the caller
  - GC.SuppressFinalize(this) is called to the prevent the Finalizer from being called since Disposal action has been taken
  - The ~DisposableClass() method is the Finalizer
    - It will only be called by the GC
    - When GC calls the finalizer, 'false' is passed to Dispose because the GC is in the process of cleaning up managed objects and Disposal is not needed.
     
  
## Asynchronous Programming

### Understanding Multi-Threading
- Computers accomplish concurrency via a functionality called Multi-Threading
- A 'thread' is an execution path within a process
  - Runs within separate operating system processes
  - Operates independently of other threads
- Most programs start in a single-thread environment
  - The single thread is created automatically by the OS
  - Also referred to as the 'main thread'
- The thread class can be used to create and start a new thread
  - One thread runs in the process's isolated environment
  - One action must wait for another action to complete
- Multi-threaded programs utilize multiple threads 
  - Share a single process's execution environment
  - On a single core CPU processing switches back and forth from one thread to another
  - On a multi-core CPU, each thread is assigned to a core

### Creating a Thread
- Another thread can be created and started
  - Using the Thread class
  - Calling the Start method



    Thread t = new Thread(new ThreadStart(ThreadMethod));
    t.Start();
    for (int i = 0; i < 4; i++)
    {
        Console.WriteLine("Main thread: Do some work.");
        Thread.Sleep(0);
    }
    t.Join();

    static void ThreadMethod()
    {
        for (int i = 0; i < 10; i++)
        {
            Console.WriteLine("ThreadProc: {0}", i);
            Thread.Sleep(0);
        }
    }


### Managing a thread
- Once a new thread is started, there are a number of properties and methods that can be called to manage it
  - The IsAlive property returns true until the thread ends
  - Each thread has a Name property useful for debugging
  - Thread.CurrentThread gives you the currently executing thread
  - A running thread can be paused using Thread.Sleep()
  - You can wait for another thread to end by calling its Join() method
  - A thread's Priority property determines how much execution time it is given
- There two main types of threads
  - FOREGROUND THREADS
    - Keep the application alive for as long as they are running
    - When completed, the application ends and any background threads terminate immediately
    - By default, threads that  are explicitly created are foreground threads
  - BACKGROUND THREADS
    - Threads that are terminated automatically when all foreground threads have completed
    - Created by setting the IsBackground property to true
    - IsBackground can be used to change a threads type
    - Excellent for tasks like polling services or logging into

### ThreadPool
- Starting a new thread requires resources
  - Normally a few hundred microseconds
  - This can become noticeable if very many threads are being created for short operations
- The ThreadPool avoids this overhead by maintaining a pool of pre-created, recyclable threads
- There are a few things to consider about the ThreadPool
  - You cannot set the Name of pooled thread, making debugging more difficult
  - Pooled threads are always background threads
  - Blocking pooled threads can degrade performance
  - A pooled thread's priority can be changed. It will be restored to normal web the thread is returned to the pool
- The Task.Run() method is new in the .NET Framework 4.5
  - It starts a task that is executed on a thread from the ThreadPool
  - Remember that threads from the ThreadPool are background threads

  
    Task.Run(() =>
    {
        Console.WriteLine("Task running on a thread from threadpool");
        Console.WriteLine("Thread id: {0}", Thread.CurrentThread.ManagedThreadId);
    });
    Console.WriteLine("Main thread done.");


### Async and Await
- Computed are designed to carry out actions synchronously
  - Complete task A, then task B, then task C
- Asynchronous procession makes this more efficient
  - Task A is started, then task B, then task C
  - Task A is not completed before task B is started
- Async is used to mark a method to inform the compiler to look the Await keyword
  - The await keyword tells the compiler that the ASync method can't continue past that point until the awaited asynchronous process is completed
  - In the meantime, control returns to the called of the Async method
  - Async caller and Await method run simultaneously


    class Program 
    { 
      AsyncAwaitDemo demo = new AsyncAwaitDemo();
      demo.DoSomethingAsync();

      for (int i = 0; i < 10; i++)
      {
        Console.WriteLine("Main thread: Do some work.");
        Thread.Sleep(0);
      }
    }

    class AsyncAwaitDemo
    {
      public async void DoSomethingAsync()
      {
        await Task.Run(() => DoSomething());
      }

      public void DoSomething()
      {
        for (int i = 0; i < 10; i++)
        {
          Console.WriteLine("DoSomething: {0}", i);
          Thread.Sleep(0);
        }
      }
    }


## Data Security
### Basic of Assemblies
- Assemblies are the basic unit of deployment, version control, reuse, activation scoping, and security permissions
- An assembly is a container for Windows Portable Executable (PE) files
  - Contains metadata and resources
  - Contains one or more modules
  - Modules are the building blocks of an assembly
  - Modules are the units of reuse, versioning, and deployment
- We know PEs by their file extension
  - .exe - Executable
  - .dll - Dynamic Link Library
- An assembly contains up to four categories of info
  - Assembly manifest
    - The only mandatory part of an assembly
    - Describes the assembly to the managed hosting environment
    - Servers as a directory to the contents of the assembly
    - Makes the assembly self-describing
  - Application manifest
    - Provides info for the operating system
    - Deployment instructions and whether administrative elevation is required
  - Compiled types
    - Compiled IL code of types
  - Resources
    - All other data as needed

### GAG Basics
- The Global Assembly Cache (GAC) is a central repository for .NET assemblies
  - Assemblies that are shared by several apps on the computed should be stored in the GAC
- Assemblies must be 'strongly named' to be placed in the GAC
  - Generated by using the private key that corresponds to the public key distributed with the assembly
  - Strong naming an assembly creates a unique identity for the assembly... do not rely on string-name for security
- There are two ways to place an assembly in the GAC
  - Using the GACUTIL.EXE tool
  - Using the Assembly Registration Tool (RegAsm.exe)
- Default location for the GAC has been changed in .NET 4.0
  - C:\Windows\Microsoft.NET\assembly\GAC_MSIL
- There are scenarios where you explicitly do not want to install an assembly into the global assembly cache
  - XCOPY or ClickOnce deployment
  - Updating GAC assemblies can be problematic
  - Testing can be more difficult
  - Versioning can be more difficult

### Encrypting user files
- The .NET Framework makes encrypting files easy
- When working with files, the File object provides tho methods...
  - Encrypt()
  - Decrypt()
- These methods perform symmetric encryption using the Data Protection API


    string path = @"C:\Users\Public\TestFolder\WriteText.txt";
    string text = "Hello and Welcome";

    // Create a file to write to.
    File.WriteAllText(path, text);

    // Encrypt the file.
    File.Encrypt(path);

    // Decrypt the file.
    File.Decrypt(path);

    // Open the file to read from.
    Console.WriteLine(File.ReadAllText(path));

### Hashing
- What is hashing?
  - A one-way encryption technique that produces a fixed-length 'fingerprint' of data
  - Tha hash cannot be reversed
- When is hashing useful?
  - Storing and comparing data
  - Passwords are excellent candidates for hashing
  - If two hashes match, tha same value used to create both hashes
- What is salt?
  - A random value that is added to the data before hashing
  - The salt is stored with the hash
  - The salt is used to create a unique hash for each value
  - The salt is used to prevent rainbow table attacks


    class Program 
    {
      Console.WriteLine("Enter a password: ");
      string password = Console.ReadLine();
      Console.WriteLine();

      HashData hd = new HashData();
      string hash = hd.GetHash(password);
      Console.WriteLine("Hash: {0}", hash);

        Console.WriteLine("Enter the password again: ");
        string password2 = Console.ReadLine();
        Console.WriteLine();

        if (hd.VerifyHash(password2, hash))
        {
          Console.WriteLine("Passwords match");
        }
        else
        {
          Console.WriteLine("Passwords do not match");
        }

        Console.ReadLine();
    }

      
